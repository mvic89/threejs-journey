Fullscreen and Resizing notes

Our canvas current resolution is '800x600' (const = sizes)
Let's fix that and fill the whole available space

-----------------------------------------------
Fit in the viewport
Viewport is the window that shows your screen and the objects inside it.

To get the viewport width and heigt, use 'window.innerWidth' and 'window.innerHeight':
const sizes = {
  width: window.innerWidth,
  height: window.innerHeight
}

It's working but there is a margin on the top and the left, and we can scroll
This is because of the browser default stylings.

-----------------------

Now, we're going to add CSS to the 'src/style.css' file

You can write standard CSS just like you're used to, and the page will automatically reload.

A good thing to do first would be to remove any type of margin or padding on all elements by using a wildcard *:

*
{
    margin: 0;
    padding: 0;
}

Then, we can fix the canvas on the top left using its webgl class to select it:

.webgl
{
    position: fixed;
    top: 0;
    left: 0;
}

You don't need to specify width or height on the canvas because Three.js is already taking care of that when you call the renderer.setSize(...) method.

This is a good opportunity to fix a small problem on our canvas. Maybe you've noticed a blue outline on it when drag and dropping. This mostly happens on latest versions of Chrome. To fix that, we can simply add an outline: none; on the .webgl:

.webgl
{
    position: fixed;
    top: 0;
    left: 0;
    outline: none;
}

If you want to remove any type of scrolling even on touch screens, you can add an overflow: hidden on both html and body:

html,
body
{
    overflow: hidden;
}

------------------
Handle Resize

To resize the canvas, we first need to know when the window is being resized. To do so, you can listen to the resize event on window.

Add the resize listener right after the sizes variable:

window.addEventListener('resize', () =>
{
    console.log('window has been resized')
})

Now that we trigger a function when the window is being resized, we need to update few things in our code.

First, we must update the sizes variable:

window.addEventListener('resize', () =>
{
    // Update sizes
    sizes.width = window.innerWidth
    sizes.height = window.innerHeight
})

Secondly, we must update the camera aspect ratio by changing its aspect property:

window.addEventListener('resize', () =>
{
    // ...

    // Update camera
    camera.aspect = sizes.width / sizes.height
})

When you change camera properties like aspect you also need to update the projection matrix using camera.updateProjectionMatrix(). We will talk about matrices later:

window.addEventListener('resize', () =>
{
    // ...

    camera.updateProjectionMatrix()
})

Finally, we must update the renderer. Updating the renderer will automatically update the canvas width and height:

window.addEventListener('resize', () =>
{
    // ...

    // Update renderer
    renderer.setSize(sizes.width, sizes.height)
})

All together:

window.addEventListener('resize', () =>
{
    // Update sizes
    sizes.width = window.innerWidth
    sizes.height = window.innerHeight

    // Update camera
    camera.aspect = sizes.width / sizes.height
    camera.updateProjectionMatrix()

    // Update renderer
    renderer.setSize(sizes.width, sizes.height)
})

SO! basically, we create a an eventlistener that resizes the viewport by:
    1. Updating the sizes
    2. Updating the camera
    3. Updating the renderer

-----------------------------------------------------
Handle Pixel ratio

Some might see a blurry render and stairs effect (zick-zack lines) on the edges.
If so, it's because you're testing on a screen with a pixel ratio greater than 1.

The pixel ratio corresponds to how many physical pixels you have on the screen for one pixel unit on the software part.

Some background history on pixels:
A few years ago, all screens had a pixel ratio of 1 and if you looked closely you could see those pixels.
Constructors like Apple saw an opportunity and started building screens with a pixel ratio of 2.
Now, some constructors are making even higher pixel ratios like 3 and even more..

A pixel ratio of 2 means 4 times more pixels to render (it divides the pixel into 4 smaller pixels) (2x2)
A pixel ratio of 3 means 9 times more pixels to render (it divides the pixel into 9 smaller pixels) (3x3)
Highest pixel ratios are usually on the weakiest devices - mobiles (there's mobile devices with a pixel ratio of 5)

A pixel ratio higher than 3 is just stupid marketing, we don't need a pixel ratio that high.

A higher pixel ratio takes alot of GPU to render.

------------------------
To get the current pixel ratio, we can use 'window.devicePixelRatio'.
To update the 'renderer' accordingly, we can use 'renderer.setPixelRatio(...)
    'renderer.setPixelRatio(window.devicePixelRatio)

If you write 'window.devicePixelRatio' in the console.log, it will return the pixel ratio on your device (mine has 1.3 apparently)

Having a pixel ratio greater than 2 is mostly marketing. Your eyes will see almost no difference between 2 and 3 but it will create performance issues and empty the battery faster. What you can do is limit the pixel ratio to 2. To do that, you can use Math.min():

renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2))

ALSO! put the 'renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2))' inside the 'resize' eventListener, in case the user changes the window from a screen to another:

window.addEventListener('resize', () => {
    //...
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2))
})

---------------------------------------------
Handle Fullscreen

Let's say you're creating a fullscreen, because we want to create an immersive experience. or if you're building a game, and you want the player to enjoy the game with a fullscreen (no windows, no frame).

How do we do that?
Let's add support to a fullscreen mode by double clicking anywhere.
Listen to the 'dblclick' event.

window.addEventListener('dblclick', () => {
    console.log('double click')
})

We can then use an if statement on the 'document.fullscrenElement' to determine whether we're already in fullscreen or not:

window.addEventListener('dblclick', () => {
    
    if (!document.fullscrenElement) { //if document.fullscrenElement isn't true (false), console.log('go fullscreen')
        console.log('go fullscreen')
    } else { // if it's true, then console.log('leave fulllscreen')
        console.log('leave fullscreen)
    }

})

To go to the fulllscreen mode, use 'requestFullscreen()' method on the concerned element (our '<canvas>')

window.addEventListener('dblclick', () => {
    
    if (!document.fullscrenElement) { //if document.fullscrenElement isn't true (false), use requestFullscreen() on the <canvas> element.
        canvas.requestFullscreen()
    } else { // if it's true, then console.log('leave fulllscreen') // we can leave the fullscreen by pressing the 'ESC' button.
        console.log('leave fullscreen)
    }
})


To leave the fullscreen mode, use exitFullscreen() method on the 'document'

window.addEventListener('dblclick', () => {
    
    if (!document.fullscrenElement) { //if document.fullscrenElement isn't true (false), use requestFullscreen() on the <canvas> element.
        canvas.requestFullscreen()
    } else { // if it's true, then use 'exitFullscreen' method on the document object.
        document.exitFullscreen()
    }
})

Unfornutately, this won't work on Safari. (if you don't care about Safari, skip the code below) (maybe it works nowadays?)
We need prefixed versions with another nested 'if / else' statement after the 'if / else' statements:


window.addEventListener('dblclick', () =>
{
    const fullscreenElement = document.fullscreenElement || document.webkitFullscreenElement

    if(!fullscreenElement)
    {
        if(canvas.requestFullscreen)
        {
            canvas.requestFullscreen()
        }
        else if(canvas.webkitRequestFullscreen)
        {
            canvas.webkitRequestFullscreen()
        }
    }
    else
    {
        if(document.exitFullscreen)
        {
            document.exitFullscreen()
        }
        else if(document.webkitExitFullscreen)
        {
            document.webkitExitFullscreen()
        }
    }
})

// Update!
The latest versions of Safari support the fullscreen API without prefixes.

Yet, it’s considered good practice to use the prefixes for two reasons:

    Some users use old versions of Safari
    The fullscreen API is not supported on iPhone, but it’s supported on iPad, only with prefixes

------------------------------------------------
Now! everything should work fine on all modern browsers!